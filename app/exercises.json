{
  "exercises": [
    {
      "id": "go-001-goroutines",
      "title": "Goroutines Basics",
      "description": "Comprenez comment les goroutines permettent la concurrence légère en Go. Les goroutines sont des threads gérés par le runtime Go, beaucoup plus efficaces que les threads OS.",
      "domain": "golang",
      "difficulty": 1,
      "steps": [
        "Créer une goroutine simple avec 'go func()'",
        "Utiliser sync.WaitGroup pour synchroniser",
        "Comprendre le planification des goroutines"
      ],
      "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\t\n\t// TODO: Ajouter 3 goroutines qui affichent \"Hello\"\n\t// Augmenter le WaitGroup pour chacune\n\t// Appeler wg.Done() dans chaque goroutine\n\t\n\twg.Wait() // Attendre que tout est fini\n\tfmt.Println(\"Terminé!\")\n}\n",
      "tests": [
        {
          "name": "Goroutines are concurrent",
          "code": "// Vérifie que les goroutines s'exécutent en parallèle"
        }
      ],
      "completed": false,
      "last_reviewed": null,
      "ease_factor": 2.5,
      "interval_days": 0,
      "repetitions": 0,
      "next_review_date": "2025-11-17"
    },
    {
      "id": "go-002-channels",
      "title": "Channels et Communication",
      "description": "Maîtrisez les canaux pour une communication sûre entre goroutines. Les canaux sont le moyen idiomatique en Go de partager des données sans utiliser de mutex.",
      "domain": "golang",
      "difficulty": 2,
      "steps": [
        "Créer des canaux typés",
        "Envoyer et recevoir via les canaux",
        "Implémenter le pattern producteur-consommateur"
      ],
      "content": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\t// TODO: Créer un canal d'entiers\n\tch := make(chan int)\n\t\n\t// TODO: Lancer une goroutine productrice\n\t// qui envoie 1, 2, 3 dans le canal\n\t\n\t// TODO: Lancer une goroutine consommatrice\n\t// qui reçoit et affiche les valeurs\n\t\n\t// TODO: Attendre que tout soit fini\n}\n",
      "tests": [],
      "completed": true,
      "last_reviewed": "2025-11-15T14:30:00Z",
      "ease_factor": 2.6,
      "interval_days": 3,
      "repetitions": 2,
      "next_review_date": "2025-11-20"
    },
    {
      "id": "go-003-interfaces",
      "title": "Interfaces et Polymorphisme",
      "description": "Écrivez du code flexible et réutilisable avec les interfaces. Go permet une implémentation implicite, ce qui rend les interfaces très puissantes.",
      "domain": "golang",
      "difficulty": 2,
      "steps": [
        "Définir des contrats d'interface",
        "Implémenter les interfaces implicitement",
        "Utiliser interface{} pour la flexibilité"
      ],
      "content": "package main\n\nimport \"fmt\"\n\n// TODO: Créer une interface Writer avec Write(string)\n\n// TODO: Implémenter Writer pour un type Person\n// qui affiche \"Person: <name> says <message>\"\n\n// TODO: Implémenter Writer pour un type Logger\n// qui affiche \"LOG: <message>\"\n\nfunc main() {\n\t// TODO: Créer des instances et les utiliser comme Writer\n\tvar writers []interface{} // TODO: Utiliser l'interface Writer\n\t\n\tfor _, w := range writers {\n\t\tw.Write(\"Hello!\")\n\t}\n}\n",
      "tests": [],
      "completed": false,
      "last_reviewed": null,
      "ease_factor": 2.5,
      "interval_days": 0,
      "repetitions": 0,
      "next_review_date": "2025-11-17"
    },
    {
      "id": "go-004-error-handling",
      "title": "Error Handling Patterns",
      "description": "Maîtrisez les patterns de gestion d'erreurs en Go. Go traite les erreurs comme des valeurs, ce qui les rend explicites et faciles à gérer.",
      "domain": "golang",
      "difficulty": 1,
      "steps": [
        "Comprendre l'interface error",
        "Créer des types d'erreurs personnalisés",
        "Gérer les erreurs gracieusement"
      ],
      "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// TODO: Créer un type d'erreur personnalisé ValidationError\n\nfunc Validate(age int) error {\n\t// TODO: Retourner une erreur si age < 0\n\t// TODO: Retourner une erreur si age > 150\n\t// TODO: Retourner nil si valide\n\treturn nil\n}\n\nfunc main() {\n\terr := Validate(-5)\n\t// TODO: Vérifier et afficher l'erreur appropriément\n}\n",
      "tests": [],
      "completed": true,
      "last_reviewed": "2025-11-16T10:15:00Z",
      "ease_factor": 2.9,
      "interval_days": 1,
      "repetitions": 4,
      "next_review_date": "2025-11-18"
    },
    {
      "id": "linux-001-tmux",
      "title": "Tmux Window Management",
      "description": "Maîtrisez tmux pour un multiplexage de terminal efficace. Tmux permet de gérer plusieurs sessions et fenêtres sans quitter le terminal.",
      "domain": "linux",
      "difficulty": 1,
      "steps": [
        "Créer et nommer des sessions",
        "Diviser fenêtres et volets",
        "Naviguer entre les fenêtres"
      ],
      "content": "# Tmux Basics\n\n## Commandes clés:\n# Créer une session: tmux new-session -s mynotes\n# Nommer une fenêtre: Ctrl-b , puis taper le nom\n# Diviser horizontalement: Ctrl-b %\n# Diviser verticalement: Ctrl-b \"\n# Naviguer entre volets: Ctrl-b flèches\n\n# TODO: Créer une session tmux\n# TODO: Créer 2 fenêtres\n# TODO: Diviser une fenêtre en 3 volets\n# TODO: Naviguer entre tous les volets\n",
      "tests": [],
      "completed": false,
      "last_reviewed": null,
      "ease_factor": 2.5,
      "interval_days": 0,
      "repetitions": 0,
      "next_review_date": "2025-11-17"
    },
    {
      "id": "linux-002-shell-scripting",
      "title": "Shell Scripting Fundamentals",
      "description": "Apprenez le scripting bash pour automatiser les tâches système. Les scripts shell sont essentiels pour l'administration système et DevOps.",
      "domain": "linux",
      "difficulty": 2,
      "steps": [
        "Variables et conditionnels",
        "Boucles et fonctions",
        "Gestion d'erreurs avec exit codes"
      ],
      "content": "#!/bin/bash\n\n# TODO: Créer une fonction qui vérifie si un fichier existe\n# TODO: Créer une boucle qui itère sur les arguments\n# TODO: Ajouter la gestion d'erreurs avec trap\n\ncheck_file() {\n    # TODO: Implémenter\n    return 0\n}\n\n# TODO: Appeler la fonction avec différents arguments\n# TODO: Afficher les résultats\n",
      "tests": [],
      "completed": true,
      "last_reviewed": "2025-11-10T09:00:00Z",
      "ease_factor": 2.7,
      "interval_days": 5,
      "repetitions": 3,
      "next_review_date": "2025-11-22"
    },
    {
      "id": "linux-003-permissions",
      "title": "File Permissions et Ownership",
      "description": "Maîtrisez le système de permissions Linux. Comprendre rwx, chmod, et chown est crucial pour la sécurité du système.",
      "domain": "linux",
      "difficulty": 1,
      "steps": [
        "Comprendre read/write/execute",
        "Modèle user/group/other",
        "Commandes chmod et chown"
      ],
      "content": "# Linux Permissions\n\n# Format: -rwxrwxrwx\n#         ^^^^^^^^^^\n#         u g o (user, group, other)\n\n# r (read)    = 4\n# w (write)   = 2\n# x (execute) = 1\n\n# TODO: Créer un fichier\n# TODO: Donner lecture/écriture au propriétaire\n# TODO: Donner lecture seule au groupe\n# TODO: Retirer toutes les permissions aux autres\n# TODO: Afficher les permissions avec ls -l\n",
      "tests": [],
      "completed": false,
      "last_reviewed": null,
      "ease_factor": 2.5,
      "interval_days": 0,
      "repetitions": 0,
      "next_review_date": "2025-11-17"
    },
    {
      "id": "arch-001-memory-hierarchy",
      "title": "Understanding Memory Hierarchy",
      "description": "Visualisez comment CPU caches, RAM, et stockage interagissent. Comprendre la hiérarchie mémoire est crucial pour optimiser les performances.",
      "domain": "architecture",
      "difficulty": 2,
      "steps": [
        "Étudier les niveaux de cache (L1, L2, L3)",
        "Comprendre les patterns d'accès mémoire",
        "Optimiser pour la localité de cache"
      ],
      "content": "# Memory Hierarchy\n\n# Vitesse et taille:\n# L1 Cache:  32 KB  - accès: 4 cycles\n# L2 Cache:  256 KB - accès: 12 cycles\n# L3 Cache:  8 MB   - accès: 40 cycles\n# RAM:       16 GB  - accès: 200 cycles\n# Disque:    1 TB   - accès: 10,000,000+ cycles\n\n# ASCII Visualization:\n# ┌─────────────────┐\n# │ L1 (32KB)       │  ← Rapide\n# │ ┌───────────┐   │\n# │ │ L2 (256KB)│   │\n# │ │ ┌───────┐ │   │\n# │ │ │ L3    │ │   │\n# │ │ │(8 MB) │ │   │\n# │ │ │ ┌───┐ │ │   │\n# │ │ │ │RAM│ │ │   │  ← Lent\n# │ │ │ │   │ │ │   │\n# └─────────────────┘\n\n# TODO: Écrire du code Go avec bonne localité de cache\n",
      "tests": [],
      "completed": false,
      "last_reviewed": null,
      "ease_factor": 2.5,
      "interval_days": 0,
      "repetitions": 0,
      "next_review_date": "2025-11-17"
    },
    {
      "id": "arch-002-process-thread",
      "title": "Process vs Thread: Mental Model",
      "description": "Construisez un modèle mental clair de l'isolation des processus et du partage des threads. C'est fondamental pour comprendre la concurrence.",
      "domain": "architecture",
      "difficulty": 1,
      "steps": [
        "Dessiner la disposition mémoire d'un processus",
        "Comprendre le partage mémoire des threads",
        "Visualiser le context switching"
      ],
      "content": "# Process vs Thread\n\n# PROCESSUS:\n# ┌─────────────────────┐\n# │ Process A           │\n# │ ┌─────────────────┐ │\n# │ │ Code Segment    │ │\n# │ ├─────────────────┤ │\n# │ │ Data Segment    │ │\n# │ ├─────────────────┤ │  Mémoire\n# │ │ Heap            │ │  ISOLÉE\n# │ ├─────────────────┤ │\n# │ │ Stack (Thread1) │ │\n# │ └─────────────────┘ │\n# └─────────────────────┘\n#\n# THREADS (même processus):\n# ┌────────────────────────────────┐\n# │ Process A                      │\n# │ ┌──────────────────────────┐  │\n# │ │ Code Segment (PARTAGÉ)   │  │\n# │ │ Data Segment (PARTAGÉ)   │  │\n# │ │ Heap (PARTAGÉ)           │  │\n# │ ├──────┬──────┬───────────┤  │\n# │ │Stack1│Stack2│Stack3     │  │\n# │ └──────┴──────┴───────────┘  │\n# └────────────────────────────────┘\n\n# TODO: Visualiser un context switch\n# TODO: Identifier les zones partagées vs isolées\n",
      "tests": [],
      "completed": true,
      "last_reviewed": "2025-11-12T15:45:00Z",
      "ease_factor": 2.8,
      "interval_days": 4,
      "repetitions": 2,
      "next_review_date": "2025-11-19"
    },
    {
      "id": "arch-003-virtual-memory",
      "title": "Virtual Memory System",
      "description": "Comprenez la paging, la segmentation, et les lookaside buffers de traduction. C'est comment les systèmes modernes gèrent la mémoire efficacement.",
      "domain": "architecture",
      "difficulty": 3,
      "steps": [
        "Comprendre l'espace adresse virtuel",
        "Apprendre le mécanisme de paging",
        "Étudier l'optimisation TLB"
      ],
      "content": "# Virtual Memory\n\n# Address Translation:\n# Virtual Address (32-bit)\n# ┌──────────────┬────────┐\n# │ Page Number  │ Offset │\n# │ (20 bits)    │(12bits)│\n# └──────────────┴────────┘\n#        ↓\n#    Page Table Lookup\n#        ↓\n# Physical Address\n# ┌──────────────┬────────┐\n# │ Frame Number │ Offset │\n# └──────────────┴────────┘\n\n# TLB (Translation Lookaside Buffer)\n# Cache rapide des traductions récentes\n# Hit rate: 95-99%\n\n# TODO: Calculer un miss de page\n# TODO: Simuler un TLB hit/miss\n",
      "tests": [],
      "completed": false,
      "last_reviewed": null,
      "ease_factor": 2.5,
      "interval_days": 0,
      "repetitions": 0,
      "next_review_date": "2025-11-17"
    }
  ],
  "user_stats": {
    "current_streak": 5,
    "total_completed": 4,
    "total_reviews": 9,
    "last_session": "2025-11-17T10:30:00Z",
    "total_study_time_minutes": 240
  }
}
