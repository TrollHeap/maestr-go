[
  {
    "id": "1",
    "title": "Binary Search Implementation",
    "description": "Implémenter la recherche binaire en Go",
    "domain": "Algorithms",
    "difficulty": 2,
    "steps": [
      "Comprendre la complexité O(log n)",
      "Écrire le pseudo-code",
      "Implémenter en Go",
      "Tester avec différents cas"
    ],
    "content": "La recherche binaire est un algorithme efficace pour trouver un élément dans un tableau trié. Elle divise le tableau en deux à chaque itération.",
    "completed": false,
    "completed_steps": [],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-10T10:00:00Z",
    "updated_at": "2025-11-10T10:00:00Z"
  },
  {
    "id": "2",
    "title": "Linked List from Scratch",
    "description": "Créer une liste chaînée en Go",
    "domain": "Data Structures",
    "difficulty": 3,
    "steps": [
      "Définir la structure Node",
      "Implémenter Insert",
      "Implémenter Delete",
      "Ajouter des tests unitaires"
    ],
    "content": "Une liste chaînée est une structure de données linéaire où chaque élément pointe vers le suivant.",
    "completed": true,
    "completed_steps": [0, 1, 2, 3],
    "last_reviewed": "2025-11-15T14:30:00Z",
    "ease_factor": 2.3,
    "interval_days": 7,
    "repetitions": 2,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-05T10:00:00Z",
    "updated_at": "2025-11-15T14:30:00Z"
  },
  {
    "id": "3",
    "title": "QuickSort Algorithm",
    "description": "Comprendre et implémenter QuickSort",
    "domain": "Algorithms",
    "difficulty": 4,
    "steps": [
      "Comprendre le principe du pivot",
      "Implémenter la fonction de partition",
      "Implémenter la récursion",
      "Analyser la complexité temporelle"
    ],
    "content": "QuickSort utilise le principe divide-and-conquer avec un pivot pour trier efficacement.",
    "completed": false,
    "completed_steps": [0, 1],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 1,
    "deleted": false,
    "created_at": "2025-11-12T10:00:00Z",
    "updated_at": "2025-11-16T10:00:00Z"
  },
  {
    "id": "4",
    "title": "Docker Container Setup",
    "description": "Écrire un Dockerfile optimisé",
    "domain": "Docker",
    "difficulty": 2,
    "steps": [
      "Choisir l'image de base",
      "Optimiser les layers",
      "Utiliser multi-stage build",
      "Tester l'image"
    ],
    "content": "Les Dockerfiles définissent comment construire une image container de manière reproductible.",
    "completed": false,
    "completed_steps": [],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-14T10:00:00Z",
    "updated_at": "2025-11-14T10:00:00Z"
  },
  {
    "id": "5",
    "title": "Goroutines & Channels",
    "description": "Maîtriser la concurrence en Go",
    "domain": "Go Programming",
    "difficulty": 3,
    "steps": [
      "Créer des goroutines simples",
      "Utiliser des channels",
      "Implémenter select statement",
      "Éviter les race conditions"
    ],
    "content": "Les goroutines sont des threads légers gérés par le runtime Go pour la concurrence.",
    "completed": true,
    "completed_steps": [0, 1, 2, 3],
    "last_reviewed": "2025-11-17T10:00:00Z",
    "ease_factor": 2.6,
    "interval_days": 5,
    "repetitions": 3,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-08T10:00:00Z",
    "updated_at": "2025-11-17T10:00:00Z"
  },
  {
    "id": "6",
    "title": "Binary Tree Traversal",
    "description": "Implémenter les parcours d'arbres binaires",
    "domain": "Data Structures",
    "difficulty": 3,
    "steps": [
      "Comprendre in-order traversal",
      "Implémenter pre-order",
      "Implémenter post-order",
      "Comparer les différences"
    ],
    "content": "Les arbres binaires peuvent être parcourus de plusieurs façons : in-order, pre-order, post-order. Chaque méthode révèle différentes propriétés de l'arbre.",
    "completed": false,
    "completed_steps": [0],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-11T09:00:00Z",
    "updated_at": "2025-11-11T09:00:00Z"
  },
  {
    "id": "7",
    "title": "Hash Table Implementation",
    "description": "Construire une hash table from scratch",
    "domain": "Data Structures",
    "difficulty": 4,
    "steps": [
      "Choisir une fonction de hachage",
      "Gérer les collisions avec chaining",
      "Implémenter Get/Set/Delete",
      "Tester les performances"
    ],
    "content": "Les hash tables offrent O(1) en moyenne pour insertion/recherche. La gestion des collisions est cruciale.",
    "completed": false,
    "completed_steps": [],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-09T14:00:00Z",
    "updated_at": "2025-11-09T14:00:00Z"
  },
  {
    "id": "8",
    "title": "Dijkstra's Algorithm",
    "description": "Algorithme du plus court chemin",
    "domain": "Algorithms",
    "difficulty": 5,
    "steps": [
      "Comprendre les graphes pondérés",
      "Implémenter la priority queue",
      "Coder l'algorithme principal",
      "Tester sur différents graphes"
    ],
    "content": "Dijkstra trouve le chemin le plus court dans un graphe pondéré sans cycles négatifs. Utilise une priority queue pour l'optimisation.",
    "completed": true,
    "completed_steps": [0, 1, 2, 3],
    "last_reviewed": "2025-11-16T11:00:00Z",
    "ease_factor": 2.4,
    "interval_days": 10,
    "repetitions": 1,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-01T10:00:00Z",
    "updated_at": "2025-11-16T11:00:00Z"
  },
  {
    "id": "9",
    "title": "REST API avec Go",
    "description": "Créer une API REST complète",
    "domain": "Go Programming",
    "difficulty": 3,
    "steps": [
      "Setup avec Gorilla Mux",
      "Créer les handlers CRUD",
      "Ajouter middleware logging",
      "Gérer les erreurs JSON"
    ],
    "content": "Une API REST suit les principes HTTP pour exposer des ressources. Go excelle dans ce domaine grâce à net/http.",
    "completed": false,
    "completed_steps": [0, 1],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-13T15:00:00Z",
    "updated_at": "2025-11-13T15:00:00Z"
  },
  {
    "id": "10",
    "title": "Context Package Mastery",
    "description": "Maîtriser context.Context en Go",
    "domain": "Go Programming",
    "difficulty": 2,
    "steps": [
      "Comprendre context.Background",
      "Utiliser WithTimeout",
      "Implémenter WithCancel",
      "Propager correctement le context"
    ],
    "content": "Le package context permet de gérer les deadlines, cancellations et valeurs dans les appels. Essentiel pour les APIs.",
    "completed": true,
    "completed_steps": [0, 1, 2, 3],
    "last_reviewed": "2025-11-18T09:00:00Z",
    "ease_factor": 2.7,
    "interval_days": 3,
    "repetitions": 4,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-07T10:00:00Z",
    "updated_at": "2025-11-18T09:00:00Z"
  },
  {
    "id": "11",
    "title": "Docker Compose Multi-Container",
    "description": "Orchestrer plusieurs containers",
    "domain": "Docker",
    "difficulty": 3,
    "steps": [
      "Définir les services",
      "Configurer les networks",
      "Gérer les volumes",
      "Tester l'orchestration complète"
    ],
    "content": "Docker Compose simplifie le déploiement d'applications multi-containers avec un fichier YAML déclaratif.",
    "completed": false,
    "completed_steps": [0, 1],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 1,
    "deleted": false,
    "created_at": "2025-11-15T10:00:00Z",
    "updated_at": "2025-11-15T10:00:00Z"
  },
  {
    "id": "12",
    "title": "Merge Sort Implementation",
    "description": "Implémenter l'algorithme Merge Sort",
    "domain": "Algorithms",
    "difficulty": 3,
    "steps": [
      "Comprendre divide-and-conquer",
      "Implémenter la fonction merge",
      "Coder la récursion",
      "Analyser O(n log n)"
    ],
    "content": "Merge Sort garantit O(n log n) dans tous les cas. Excellent pour comprendre la récursion et le divide-and-conquer.",
    "completed": false,
    "completed_steps": [],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-10T14:00:00Z",
    "updated_at": "2025-11-10T14:00:00Z"
  },
  {
    "id": "13",
    "title": "Systemd Service Creation",
    "description": "Créer un service systemd pour Linux",
    "domain": "Linux Administration",
    "difficulty": 2,
    "steps": [
      "Écrire le fichier .service",
      "Configurer ExecStart et WorkingDirectory",
      "Activer le service avec systemctl",
      "Tester le restart automatique"
    ],
    "content": "Systemd gère les services et le démarrage du système Linux. Les fichiers .service définissent comment lancer vos applications.",
    "completed": true,
    "completed_steps": [0, 1, 2, 3],
    "last_reviewed": "2025-11-14T16:00:00Z",
    "ease_factor": 2.2,
    "interval_days": 14,
    "repetitions": 1,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-01T10:00:00Z",
    "updated_at": "2025-11-14T16:00:00Z"
  },
  {
    "id": "14",
    "title": "BFS & DFS Graph Traversal",
    "description": "Parcourir un graphe en largeur et profondeur",
    "domain": "Algorithms",
    "difficulty": 3,
    "steps": [
      "Représenter un graphe en Go",
      "Implémenter BFS avec queue",
      "Implémenter DFS avec stack",
      "Comparer les cas d'usage"
    ],
    "content": "BFS et DFS sont fondamentaux pour explorer des graphes. BFS utilise une queue, DFS une stack (ou récursion).",
    "completed": false,
    "completed_steps": [0, 1],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-12T11:00:00Z",
    "updated_at": "2025-11-12T11:00:00Z"
  },
  {
    "id": "15",
    "title": "Heap Data Structure",
    "description": "Implémenter un tas binaire (min-heap)",
    "domain": "Data Structures",
    "difficulty": 4,
    "steps": [
      "Comprendre la propriété du tas",
      "Implémenter Insert avec heapify-up",
      "Implémenter ExtractMin avec heapify-down",
      "Tester avec priority queue"
    ],
    "content": "Les tas (heaps) permettent d'implémenter des priority queues efficaces. Insert et ExtractMin en O(log n).",
    "completed": false,
    "completed_steps": [],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 2,
    "deleted": false,
    "created_at": "2025-11-08T10:00:00Z",
    "updated_at": "2025-11-08T10:00:00Z"
  },
  {
    "id": "16",
    "title": "SQL Queries Optimization",
    "description": "Optimiser des requêtes SQL complexes",
    "domain": "Databases",
    "difficulty": 3,
    "steps": [
      "Analyser EXPLAIN PLAN",
      "Ajouter des index appropriés",
      "Réécrire avec JOIN optimisés",
      "Mesurer les gains de performance"
    ],
    "content": "L'optimisation SQL passe par l'analyse des plans d'exécution et l'utilisation intelligente des index.",
    "completed": false,
    "completed_steps": [0],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-11T10:00:00Z",
    "updated_at": "2025-11-11T10:00:00Z"
  },
  {
    "id": "17",
    "title": "Dynamic Programming: Fibonacci",
    "description": "Résoudre Fibonacci avec programmation dynamique",
    "domain": "Algorithms",
    "difficulty": 2,
    "steps": [
      "Comprendre la récursion naïve",
      "Implémenter memoization (top-down)",
      "Implémenter tabulation (bottom-up)",
      "Comparer les performances"
    ],
    "content": "La programmation dynamique optimise les problèmes avec sous-problèmes répétés. Fibonacci est l'exemple classique.",
    "completed": true,
    "completed_steps": [0, 1, 2, 3],
    "last_reviewed": "2025-11-17T14:00:00Z",
    "ease_factor": 2.8,
    "interval_days": 4,
    "repetitions": 5,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-06T10:00:00Z",
    "updated_at": "2025-11-17T14:00:00Z"
  },
  {
    "id": "18",
    "title": "Bash Script Automation",
    "description": "Automatiser des tâches avec Bash",
    "domain": "Linux Administration",
    "difficulty": 2,
    "steps": [
      "Comprendre les variables et arguments",
      "Gérer les conditions if/else",
      "Implémenter error handling",
      "Ajouter des logs"
    ],
    "content": "Bash permet d'automatiser des tâches répétitives sur Linux. Essentiel pour l'administration système.",
    "completed": false,
    "completed_steps": [0, 1],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-13T10:00:00Z",
    "updated_at": "2025-11-13T10:00:00Z"
  },
  {
    "id": "19",
    "title": "Trie Data Structure",
    "description": "Implémenter un arbre de préfixes (Trie)",
    "domain": "Data Structures",
    "difficulty": 4,
    "steps": [
      "Définir la structure TrieNode",
      "Implémenter Insert",
      "Implémenter Search",
      "Ajouter StartsWith (prefix search)"
    ],
    "content": "Un Trie est efficace pour stocker et rechercher des mots. Utilisé dans les auto-complétions et dictionnaires.",
    "completed": false,
    "completed_steps": [],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-09T10:00:00Z",
    "updated_at": "2025-11-09T10:00:00Z"
  },
  {
    "id": "20",
    "title": "Microservices avec Go",
    "description": "Architecture microservices en Go",
    "domain": "Go Programming",
    "difficulty": 5,
    "steps": [
      "Définir les bounded contexts",
      "Implémenter communication HTTP/gRPC",
      "Ajouter service discovery",
      "Gérer la résilience (circuit breaker)"
    ],
    "content": "Les microservices décomposent une application en services indépendants. Go est parfait pour construire des services performants.",
    "completed": false,
    "completed_steps": [0],
    "ease_factor": 2.5,
    "interval_days": 0,
    "repetitions": 0,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-15T10:00:00Z",
    "updated_at": "2025-11-15T10:00:00Z"
  }
]
