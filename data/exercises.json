[
  {
    "id": 1,
    "title": "Tri rapide (Quicksort)",
    "description": "Implémenter l'algorithme de tri rapide en Go",
    "domain": "Algorithmes",
    "difficulty": 4,
    "steps": [
      "Comprendre le principe du pivot",
      "Implémenter la partition",
      "Récursion gauche et droite",
      "Tester avec des cas limites"
    ],
    "content": "<h1>Quicksort en Go</h1>\n\n<p>Le tri rapide est un algorithme de tri par comparaison utilisant la stratégie diviser pour régner.</p>\n\n<h2>Principe</h2>\n\n<ol>\n<li>Choisir un pivot</li>\n<li>Partitionner autour du pivot</li>\n<li>Trier récursivement les deux sous-parties</li>\n</ol>\n\n<h2>Complexité</h2>\n\n<ul>\n<li>Moyenne: O(n log n)</li>\n<li>Pire cas: O(n²) si pivot mal choisi</li>\n</ul>\n\n<h2>Implémentation</h2>\n\n<pre>de>\n## Tests\n\n</code></pre>\n",
    "conceptual_visuals": [
      {
        "type": "ascii",
        "content": "┌──────────────────────────────┐\n│ QUICKSORT = Diviser & Régner │\n├──────────────────────────────┤\n│                              │\n│     [8, 3, 1, 7, 0, 10, 2]   │\n│              ↓               │\n│        Choisir pivot (7)     │\n│              ↓               │\n│  ┌───────────┼───────────┐  │\n│  │           │           │  │\n│ [3,1,0,2]    7      [8,10]  │\n│  petits   pivot   grands    │\n│    ↓                  ↓      │\n│ trier()           trier()   │\n│    ↓                  ↓      │\n│ [0,1,2,3]  +  7  +  [8,10]  │\n│              ↓               │\n│     [0,1,2,3,7,8,10]        │\n│                              │\n└──────────────────────────────┘",
        "caption": "Partition autour du pivot puis récursion sur les sous-parties"
      },
      {
        "type": "ascii",
        "content": "ARBRE DE RÉCURSION\n──────────────────\n\n      [8,3,1,7,0,10,2]\n            ↓\n      partition(7)\n            ↓\n    ┌───────┼───────┐\n    │               │\n[3,1,0,2]          [8,10]\n    ↓               ↓\npartition(2)   partition(9)\n    ↓               ↓\n┌───┼───┐       ┌──┼──┐\n│       │       │     │\n[0,1] [3] [2]   [8] [10]\n  ↓     ↓   ↓    ↓    ↓\nDONE DONE DONE DONE DONE",
        "caption": "Chaque niveau divise le problème jusqu'aux cas de base (≤1 élément)"
      }
    ],
    "mnemonic": "Chef d'orchestre : petits musiciens ← pivot → grands musiciens",
    "done": false,
    "completed_steps": [0, 2],
    "last_reviewed_date": 20251128,
    "next_review_date": 20251230,
    "ease_factor": 1.3,
    "interval_days": 32,
    "repetitions": 6,
    "skipped_count": 0,
    "last_skipped_date": null,
    "deleted": false,
    "created_at": 20251124,
    "updated_at": 20251128
  },
  {
    "id": 2,
    "title": "Filtrage de slice",
    "description": "Créer une fonction générique de filtrage",
    "domain": "Go",
    "difficulty": 2,
    "steps": [
      "Définir la signature avec generics",
      "Implémenter la boucle de filtrage",
      "Écrire les tests unitaires"
    ],
    "content": "<h1>Filtrage avec Go Generics</h1>\n\n<p>Depuis Go 1.18, les generics permettent de créer des fonctions type-safe réutilisables.</p>\n\n<h2>Fonction Filter générique</h2>\n\n<pre>de>\n## Usage\n\n</code></pre>\n\n<h2>Tests</h2>\n\n<p>&rdquo;&ldquo;&rdquo;</p>\n",
    "conceptual_visuals": [
      {
        "type": "ascii",
        "content": "┌─────────────────────────────┐\n│  FILTER = Sélection         │\n├─────────────────────────────┤\n│                             │\n│ Input: [1, 2, 3, 4, 5, 6]   │\n│                             │\n│         ↓ predicate(x>3)    │\n│                             │\n│    ┌────┼────┬────┬────┐    │\n│    │    │    │    │    │    │\n│    1    2    3    4    5    │\n│    ❌   ❌   ❌   ✅   ✅   │\n│                  │    │     │\n│                  └────┘     │\n│                    ↓        │\n│            Output: [4, 5]   │\n│                             │\n└─────────────────────────────┘",
        "caption": "Seuls les éléments validant le prédicat passent dans le résultat"
      },
      {
        "type": "ascii",
        "content": "GENERICS [T any]\n────────────────\n\n    Filter[int]     Filter[string]\n        ↓                ↓\n   []int input      []string input\n        ↓                ↓\n  func(int) bool   func(string) bool\n        ↓                ↓\n   []int result    []string result\n\n✅ Type-safe à la compilation\n✅ Pas de interface{}\n✅ Réutilisable pour tous types",
        "caption": "Même code, types différents grâce aux generics"
      }
    ],
    "mnemonic": "Filtre à café : garde ce qui passe le test, rejette le reste",
    "done": false,
    "completed_steps": [0, 1, 2],
    "last_reviewed_date": 20251128,
    "next_review_date": 20251130,
    "ease_factor": 1.3,
    "interval_days": 2,
    "repetitions": 2,
    "skipped_count": 0,
    "last_skipped_date": null,
    "deleted": false,
    "created_at": 20251124,
    "updated_at": 20251128
  },
  {
    "id": 3,
    "title": "Error Wrapping en Go 1.13+",
    "description": "Maîtriser fmt.Errorf(%w) et errors.Is/As pour tracer les erreurs",
    "domain": "Go",
    "difficulty": 3,
    "steps": [
      "Comprendre la stack d'erreurs (wrapping)",
      "Utiliser %w dans fmt.Errorf",
      "Tester avec errors.Is() et errors.As()",
      "Appliquer dans un projet réel (http handler)"
    ],
    "content": "<h1>Error Wrapping en Go</h1>\n\n<p>Depuis Go 1.13, les erreurs peuvent être wrappées pour conserver le contexte.</p>\n\n<h2>Principe</h2>\n\n<pre>de>\n## Unwrapping\n\n</code></pre>\n\n<h2>Différence %v vs %w</h2>\n\n<pre>de>\n## Application HTTP Handler\n\n</code></pre>\n",
    "conceptual_visuals": [
      {
        "type": "ascii",
        "content": "┌────────────────────────────────┐\n│  ERROR WRAPPING = Stack Trace  │\n├────────────────────────────────┤\n│                                │\n│  Niveau 3 (User/API)           │\n│  ┌──────────────────────────┐  │\n│  │ processConfig: ...       │  │\n│  └─────────┬────────────────┘  │\n│            │ wraps (%w)        │\n│            ↓                   │\n│  Niveau 2 (Logic)              │\n│  ┌──────────────────────────┐  │\n│  │ readFile \"/etc/cfg\": ... │  │\n│  └─────────┬────────────────┘  │\n│            │ wraps (%w)        │\n│            ↓                   │\n│  Niveau 1 (OS)                 │\n│  ┌──────────────────────────┐  │\n│  │ os.ReadFile: no such     │  │\n│  │ file or directory        │  │\n│  └──────────────────────────┘  │\n│                                │\n│  errors.Is() traverse ↑        │\n│  errors.As() extrait type      │\n│                                │\n└────────────────────────────────┘",
        "caption": "Chaque niveau ajoute du contexte avec %w tout en préservant l'erreur originale"
      },
      {
        "type": "ascii",
        "content": "COMPARAISON\n───────────\n\n❌ Sans wrapping (perte contexte)\n   return fmt.Errorf(\"erreur: %v\", err)\n   → Coupe la chaîne, errors.Is() fail\n\n✅ Avec wrapping (contexte préservé)\n   return fmt.Errorf(\"contexte: %w\", err)\n   → Garde la chaîne, errors.Is() marche\n\nEXEMPLE:\n  err := readConfig()\n  \n  // Avec %w:\n  if errors.Is(err, os.ErrNotExist) { ✅\n      // Détection marche !\n  }\n  \n  // Sans %w:\n  if errors.Is(err, os.ErrNotExist) { ❌\n      // Ne sera jamais vrai\n  }",
        "caption": "Le %w est crucial pour maintenir la chaîne d'erreurs traversable"
      }
    ],
    "mnemonic": "Emballage cadeau : erreur → contexte → trace complète",
    "done": false,
    "completed_steps": [0, 1],
    "last_reviewed_date": 20251128,
    "next_review_date": 20251129,
    "ease_factor": 1.3,
    "interval_days": 1,
    "repetitions": 1,
    "skipped_count": 0,
    "last_skipped_date": null,
    "deleted": false,
    "created_at": 20251124,
    "updated_at": 20251128
  }
]
