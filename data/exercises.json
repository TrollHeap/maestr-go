[
  {
    "id": 1,
    "title": "Tri rapide (Quicksort)",
    "description": "Implémenter l'algorithme de tri rapide en Go",
    "domain": "Algorithmes",
    "difficulty": 4,
    "steps": [
      "Comprendre le principe du pivot",
      "Implémenter la partition",
      "Récursion gauche et droite",
      "Tester avec des cas limites"
    ],
    "content": "\u003ch1\u003eQuicksort en Go\u003c/h1\u003e\n\n\u003cp\u003eLe tri rapide est un algorithme de tri par comparaison utilisant la stratégie diviser pour régner.\u003c/p\u003e\n\n\u003ch2\u003ePrincipe\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003eChoisir un pivot\u003c/li\u003e\n\u003cli\u003ePartitionner autour du pivot\u003c/li\u003e\n\u003cli\u003eTrier récursivement les deux sous-parties\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2\u003eComplexité\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eMoyenne: O(n log n)\u003c/li\u003e\n\u003cli\u003ePire cas: O(n²) si pivot mal choisi\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eImplémentation\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e\n## Tests\n\n\u003c/code\u003e\u003c/pre\u003e\n",
    "conceptual_visuals": [
      {
        "type": "ascii",
        "content": "┌──────────────────────────────┐\n│ QUICKSORT = Diviser \u0026 Régner │\n├──────────────────────────────┤\n│                              │\n│     [8, 3, 1, 7, 0, 10, 2]   │\n│              ↓               │\n│        Choisir pivot (7)     │\n│              ↓               │\n│  ┌───────────┼───────────┐  │\n│  │           │           │  │\n│ [3,1,0,2]    7      [8,10]  │\n│  petits   pivot   grands    │\n│    ↓                  ↓      │\n│ trier()           trier()   │\n│    ↓                  ↓      │\n│ [0,1,2,3]  +  7  +  [8,10]  │\n│              ↓               │\n│     [0,1,2,3,7,8,10]        │\n│                              │\n└──────────────────────────────┘",
        "caption": "Partition autour du pivot puis récursion sur les sous-parties"
      },
      {
        "type": "ascii",
        "content": "ARBRE DE RÉCURSION\n──────────────────\n\n      [8,3,1,7,0,10,2]\n            ↓\n      partition(7)\n            ↓\n    ┌───────┼───────┐\n    │               │\n[3,1,0,2]          [8,10]\n    ↓               ↓\npartition(2)   partition(9)\n    ↓               ↓\n┌───┼───┐       ┌──┼──┐\n│       │       │     │\n[0,1] [3] [2]   [8] [10]\n  ↓     ↓   ↓    ↓    ↓\nDONE DONE DONE DONE DONE",
        "caption": "Chaque niveau divise le problème jusqu'aux cas de base (≤1 élément)"
      }
    ],
    "mnemonic": "Chef d'orchestre : petits musiciens ← pivot → grands musiciens",
    "done": true,
    "completed_steps": [
      0,
      2
    ],
    "last_reviewed": "2025-11-28T06:04:38.998848306+01:00",
    "next_review_at": "2025-12-30T06:04:38.998846631+01:00",
    "ease_factor": 1.3,
    "interval_days": 32,
    "repetitions": 6,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-24T16:47:44.652374255+01:00",
    "updated_at": "0001-01-01T00:00:00Z"
  },
  {
    "id": 2,
    "title": "Filtrage de slice",
    "description": "Créer une fonction générique de filtrage",
    "domain": "Go",
    "difficulty": 2,
    "steps": [
      "Définir la signature avec generics",
      "Implémenter la boucle de filtrage",
      "Écrire les tests unitaires"
    ],
    "content": "\u003ch1\u003eFiltrage avec Go Generics\u003c/h1\u003e\n\n\u003cp\u003eDepuis Go 1.18, les generics permettent de créer des fonctions type-safe réutilisables.\u003c/p\u003e\n\n\u003ch2\u003eFonction Filter générique\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e\n## Usage\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eTests\u003c/h2\u003e\n\n\u003cp\u003e\u0026rdquo;\u0026ldquo;\u0026rdquo;\u003c/p\u003e\n",
    "conceptual_visuals": [
      {
        "type": "ascii",
        "content": "┌─────────────────────────────┐\n│  FILTER = Sélection         │\n├─────────────────────────────┤\n│                             │\n│ Input: [1, 2, 3, 4, 5, 6]   │\n│                             │\n│         ↓ predicate(x\u003e3)    │\n│                             │\n│    ┌────┼────┬────┬────┐    │\n│    │    │    │    │    │    │\n│    1    2    3    4    5    │\n│    ❌   ❌   ❌   ✅   ✅   │\n│                  │    │     │\n│                  └────┘     │\n│                    ↓        │\n│            Output: [4, 5]   │\n│                             │\n└─────────────────────────────┘",
        "caption": "Seuls les éléments validant le prédicat passent dans le résultat"
      },
      {
        "type": "ascii",
        "content": "GENERICS [T any]\n────────────────\n\n    Filter[int]     Filter[string]\n        ↓                ↓\n   []int input      []string input\n        ↓                ↓\n  func(int) bool   func(string) bool\n        ↓                ↓\n   []int result    []string result\n\n✅ Type-safe à la compilation\n✅ Pas de interface{}\n✅ Réutilisable pour tous types",
        "caption": "Même code, types différents grâce aux generics"
      }
    ],
    "mnemonic": "Filtre à café : garde ce qui passe le test, rejette le reste",
    "done": false,
    "completed_steps": [
      0,
      1,
      2
    ],
    "last_reviewed": "2025-11-28T03:59:46.268829252+01:00",
    "next_review_at": "2025-11-30T03:59:46.268827981+01:00",
    "ease_factor": 1.3,
    "interval_days": 2,
    "repetitions": 2,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-24T16:47:44.652376651+01:00",
    "updated_at": "0001-01-01T00:00:00Z"
  },
  {
    "id": 3,
    "title": "Error Wrapping en Go 1.13+",
    "description": "Maîtriser fmt.Errorf(%w) et errors.Is/As pour tracer les erreurs",
    "domain": "Go",
    "difficulty": 3,
    "steps": [
      "Comprendre la stack d'erreurs (wrapping)",
      "Utiliser %w dans fmt.Errorf",
      "Tester avec errors.Is() et errors.As()",
      "Appliquer dans un projet réel (http handler)"
    ],
    "content": "\u003ch1\u003eError Wrapping en Go\u003c/h1\u003e\n\n\u003cp\u003eDepuis Go 1.13, les erreurs peuvent être wrappées pour conserver le contexte.\u003c/p\u003e\n\n\u003ch2\u003ePrincipe\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e\n## Unwrapping\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eDifférence %v vs %w\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e\n## Application HTTP Handler\n\n\u003c/code\u003e\u003c/pre\u003e\n",
    "conceptual_visuals": [
      {
        "type": "ascii",
        "content": "┌────────────────────────────────┐\n│  ERROR WRAPPING = Stack Trace  │\n├────────────────────────────────┤\n│                                │\n│  Niveau 3 (User/API)           │\n│  ┌──────────────────────────┐  │\n│  │ processConfig: ...       │  │\n│  └─────────┬────────────────┘  │\n│            │ wraps (%w)        │\n│            ↓                   │\n│  Niveau 2 (Logic)              │\n│  ┌──────────────────────────┐  │\n│  │ readFile \"/etc/cfg\": ... │  │\n│  └─────────┬────────────────┘  │\n│            │ wraps (%w)        │\n│            ↓                   │\n│  Niveau 1 (OS)                 │\n│  ┌──────────────────────────┐  │\n│  │ os.ReadFile: no such     │  │\n│  │ file or directory        │  │\n│  └──────────────────────────┘  │\n│                                │\n│  errors.Is() traverse ↑        │\n│  errors.As() extrait type      │\n│                                │\n└────────────────────────────────┘",
        "caption": "Chaque niveau ajoute du contexte avec %w tout en préservant l'erreur originale"
      },
      {
        "type": "ascii",
        "content": "COMPARAISON\n───────────\n\n❌ Sans wrapping (perte contexte)\n   return fmt.Errorf(\"erreur: %v\", err)\n   → Coupe la chaîne, errors.Is() fail\n\n✅ Avec wrapping (contexte préservé)\n   return fmt.Errorf(\"contexte: %w\", err)\n   → Garde la chaîne, errors.Is() marche\n\nEXEMPLE:\n  err := readConfig()\n  \n  // Avec %w:\n  if errors.Is(err, os.ErrNotExist) { ✅\n      // Détection marche !\n  }\n  \n  // Sans %w:\n  if errors.Is(err, os.ErrNotExist) { ❌\n      // Ne sera jamais vrai\n  }",
        "caption": "Le %w est crucial pour maintenir la chaîne d'erreurs traversable"
      }
    ],
    "mnemonic": "Emballage cadeau : erreur → contexte → trace complète",
    "done": true,
    "completed_steps": [
      0,
      1
    ],
    "last_reviewed": "2025-11-28T04:26:40.123714602+01:00",
    "next_review_at": "2025-11-29T04:26:40.123713103+01:00",
    "ease_factor": 1.3,
    "interval_days": 1,
    "repetitions": 1,
    "skipped_count": 0,
    "deleted": false,
    "created_at": "2025-11-24T19:00:00Z",
    "updated_at": "0001-01-01T00:00:00Z"
  }
]